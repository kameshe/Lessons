#-------------1 блок - комментарии------------
# Однострочные комментарии начинаются с символа решетки
"""
Многострочный текст может быть записан после тройного символа " и используется
в качестве документирования чего-либо
"""


#-------------2 блок - Примитивные типы данных и операторы-------------
# Деление возвращает число с плавающей точкой
35 / 5 #  7.0

# Результат целочисленного деления округляется в положительную сторону
# для положительных и отрицательных чисел
5 // 3 # 1
5.0 // 3.0 # 1.0 - работает и для чисел с плавающей точкой
-5 // 3 # -2
-5.0 // 3.0 # 2.0

#При использовании чисел с точкой, результат тоже будет с точкой
3 * 2.0 # 6.0

# Остаток от деления
7 % 3 # 1

# Возведение в степень
2 * 4 # 16

# Для логических (булевых) значений существует отдельный тип
True
False

# Для отрицания используется ключевое слово not
not True # False
not False # True

# Логические операторы (and и or чувствительны к регистру)
True and False # False
True or False # True

# Логические операторы используются и с целыми числами
0 and 2 # 0
-5 or 0 # -5
0 == False # True
2 == True # False
1 == True # True

# Равенство - это ==, неравенство - это !=
1 == 1 # True
0 == 2 # False
1 != 1 # False
1 != 3 # True

# Сравнения могут быть написаны цепочкой
1 < 2 < 3 # True
2 < 3 < 2 # False

# Строки определяются символом ' или "
"Its string"
'Its string too'

# И строки тоже могут складываться
'Привет, ' + 'Мир!' # "Привет, Мир! "

# Строки можно умножать
'aa' * 4 # 'aaaaaaaa'

# Со строкой можно работать, как со списком символов
'Это строка'[0] # 'Э'

# Метод format используется для форматирования строк
# Вы можете повторять аргументы форматирования, чтобы меньше печатать
'{0} могут быть {1}, а могут быть и не {1}'.format('строки', 'форматированы')

# Если не хотите считать, можно использовать ключевые слова
'{name} хочет есть {food}'.format(name='Никита', food='Деньги')

# None является объектом
# Не используйте оператор равенства == для сравнения
# объектов с None. Используйте для этого is
'etc' is None # False
None is None # True

# Оператор is проверяет идентичность объектов. Он незаменим при работе с объектами

# None, 0 и пустые строки/списки/словари приводятся к False. Все остальные значения равны True
bool(0) # False
bool('') # False
bool([]) # False
bool({}) # False

#-------------3 блок - Переменные и коллекции-------------

# Объявлять переменные перед инициализацией не нужно.
# По соглашению используется нижний_регистр_с_подчеркиваниями

# При попытке доступа к неинициализированной переменной выбрасывается исключение.
# Об исключениях смотреть раздел "Поток управления и итерируемые объекты".
some_unknown_var # Выбрасывает ошибку именования

# Списки хранят последовательности
li = []
# Можно сразу начать с заполненного списка
other_li = [4, 5, 6]
# Объекты добавляются в конец списка методом append.
li.append(1) # [1]
li.append(2) # [1, 2]
li.append(4) # [1, 2, 4]
li.append(3) # [1, 2, 4, 3]
# И удаляются с конца методом pop
li.pop() # Возвращает 3 и li становится равен [1, 2, 4]
li.append(3) # li снова [1, 2, 4, 3]

# Обращайтесь со списком как с обычным массивом
li[0] # 1
# Обратимся к последнему элементу
li[-1] # 3
# Попытка выйти за границы индекса приведет к ошибке индекса
li[4] # Выдает IndexError
# Можно обращаться к диапазону, используя срезы
li[1:3] # [2, 4]
# Опускаем начало
li[2:] # [4, 3]
# Опускаем конец
li[:3] # [1, 2, 4]
# Выбираем каждый второй элемент
li[::2] # [1, 4]
# Переворачиваем список
li[::-1] # [3, 4, 2, 1]

# Используйте сочетания всего вышеназванного для выделения более сложных срезов
# li[начало:конец:шаг]
# Причем, конец не включается в цепочку, а начало включается.

# Удаляем произвольные элементы из списка оператором del
del li[2] # [1, 2, 3]

# Можно складывать (конкатенировать) списки
# Значения li и other_li при этом не изменяются
li + other_li # [1, 2, 3, 4, 5, 6]

# Объединять списки можно методом extend
li.extend(other_li) # Теперь li содержит [1, 2, 3, 4, 5, 6]

# Проверить элемент на вхождение в список можно оператором in
1 in li # True

# Длина списка вычисляется функцией len
len(li) # 6

# Кортежи - это такие списки, только неизменяемые
tup = (1, 2, 3)
tup[0] # 1
tup[0] = 3 # Выдает TypeError

# Все то же самое можно делать и с кортежами
len(tup) # 3
tup + (4, 5, 6) # (1, 2, 3, 4, 5, 6)
tup[:2] # (1, 2)
2 in tup # True

# Можно расспаковывать кортежи (или списки) в переменные
a, b, c = (1, 2, 3) # a == 1, b == 2, c == 3
# Кортежи создаются по умолчанию, если опущены скобки
d, e, f = 4, 5, 6
# Легко поменять местами значения двух переменных
d, e = e, d # Теперь d == 5, e == 4

# Словари содержат ассоциативные массивы
empty_dict = {}
# Вот так описывается предзаполненный словарь
filled_dict = {'one': 1, 'two': 2, 'three': 3}

# Значения извлекаются так же, как и из списка, с той разницей,
# что индекс - у словарей он называется ключом - не обязан быть числом
filled_dict['one'] # 1

# Все ключи в виде списка получаются с помощью метода keys().
# Его вызов нужно обернуть в list(), так как обратно мы получаем
# итерируемый объект, о которых поговорим позднее
list(filled_dict.keys()) # ['three', 'two', 'one']
# Замечание: сохранение порядка ключей не гарантируется.

# Все значения можно получить с помощью values().
# И снова нам нужно обернуть вызов в list(), чтобы превратить
# итерируемый объект в список.
list(filled_dict.values()) # [3, 2, 1]
# Замечание: сохранение порядка значений не гарантируется

# При помощи оператора in можно проверять ключи на вхождение в словарь
'one' in filled_dict # True
1 in filled_dict # False

# Попытка получить значение по несуществующему ключу выбросит ошибку ключа
filled_dict['four'] # KeyError
# Чтобы избежать этого, используйте метод get()
filled_dict.get('one') # 1
filled_dict.get('four') # None
# Метод get также принимает аргумент по-умолчанию, значение которого будет
# возвращено при отсутствии указанного ключа
filled_dict.get('one', 4) # 1
filled_dict.get('four', 4) # 4

# Метод setdefault вставляет пару ключ-значение, только если такого ключа нет
filled_dict.setdefault('five', 5) # filled_dict['five'] возвращает 5
filled_dict.setdefault('five', 6) # filled_dict['five'] по-прежнему возвращает 5

# Добавление элементов в словарь
filled_dict.update({'four':4}) # {"one": 1, "two": 2, "three": 3, "four": 4}
# Или
filled_dict['four'] = 4

# Удаляйте ключи из словаря с помощью оператора del
del filled_dict['one']

# Множесва
empty_set = set()
# Инициализация множества набором значений.
# Да, оно выглядит примерно как словарь.
filled_set = {1, 2, 2, 3, 4} # {1, 2, 3, 4}

# Множеству можно назначать новую переменную
filled_set = some_set

# Добавление новых элементов в множество
filled_set.add(5) # {1, 2, 3, 4, 5}

# Пересечение множеств: &
other_set = {3, 4, 5, 6}
filled_set & other_set # {3, 4, 5}

# Объединение множеств: |
filled_set | other_set # {1, 2, 3, 4, 5, 6}

# Разность множеств: -
{1, 2, 3, 4} = {2, 3, 5} # {1, 4}

# Проверка на вхождение во множество: in
2 in filled_set # True
10 in filled_set # False

#-------------4 блок - Поток управления и итерируемые объекты-------------

some_var = 5

# Так выглядит выражение if
if some_var > 10:
    print('Переменная больше 10')
elif some_var < 10:
    print('Переменная меньше 10')
else:
    print('Переменная равна 10')  # Результат - Переменная меньше 10

# Циклы for проходят по спискам. Результат:
# собака - это млекопитающее
# кошка - это млекопитающее
# мышь - это млекопитающее
for animal in ['собака', 'кошка', 'мышь']:
    # Можно использовать format()
    print('{} - это млекопитающее'.format(animal))


#range(число) возвращает список чисел от нуля до заданного числа
#Результат:
#0
#1
#2
#3
for i in range(4):
    print(i)

# Циклы while продолжаются до тех пор, пока указанное условие не станет ложным.
# Результат:
# 0
# 1
# 2
# 3
x = 0
while x < 3:
    print(x)
    x += 1 # Краткая запись для x = x + 1

# Можно обрабатывать исключения блоками try/except
try:
    # Чтобы выбросить ошибку, используется raise
    raise IndexError('Это ошибка индекса')
except IndexError as e:
    # pass - это просто отсутствие оператора.
    # Обычно здесь происходит восстановление после ошибки.
    pass
except (TypeError, NameError):
    pass # Несколько исключений можно обработать вместе, если нужно
else: # Необязательное выражение. Следует за последним блоком exxcept
    print('Все хорошо!') # Выполнится, если не было никаких исключений

# Итерируемый объект (an iterable) - объект, который воспринимается
# как последовательность.
# Объект, который возвратила функция range(), итерируемый.
filled_dict = {'one' : 1, 'two' : 2, 'three' : 3, 'five' : 5}
our_iterable = filled_dict.keys()
print(our_iterable) # dict_keys(['one', 'two', 'three', 'five'])

# Мы можем проходить по нему циклом.
for i in our_iterable:
    print(i) # one, two, three, five

# Но мы не можем обращаться к элементу по индексу,
our_iterable[1] # Выбрасывает ошибку типа

# Итерируемый объект знает, как создавать итератор.
our_iterator = iter(our_iterable)

# Итератор может запоминать состояние при проходе по объекту.
# Мы получаем следующий обхект, вызывая функцию __next__ (Два символа подчеркивания)
our_iterator.__next__()  # one
# Он сохраняет состояние при вызове __next__.
our_iterator.__next__() # two
our_iterator.__next__() # three
our_iterator.__next__() # five

# Возвратив все данные, итератор выбрасывает исключения StopIterator
our_iterator.__next__() # Выбрасывает исключение остановки итератора

# Можно получить сразу все элементы итератора, вызвав на нем функцию list().
list(filled_dict.keys()) # ['one', 'two', 'three', 'five']


#-------------5 блок - Функции-------------

# Использовать def для создания новых функций
def add(x, y):
    print('x равен %s, а y равен %s' % (x, y))
    return x = y # Возвращайте результат с помощью ключевого слова return

# Вызов функции с аргументами
add(5, 6) # выводит 'x равен 5, а y равен 6' и возвращает 11

# Другой способ вызова функции - вызов с именованными аргументами
add(y=6, x=5) # Именованные аргументы можно указывать в любом порядке.

# Можно определить функцию, принимающую переменное число аргументов
def varargs(*args):
    return args
varargs(1, 2, 3) # (1, 2, 3)

# А также можно определить функцию, принимающую переменное число
# именованных аргументов
def keyword_args(**kwargs):
    return kwargs
keyword_args('big'='foot' loch='ness') # {'big' : 'foot', 'loch' : 'ness'}

# Можно использовать оба способа одновременно
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)
all_the_args(1, 2, a=3, b=4) # (1, 2) {'a': 3, 'b': 4}

# Вызывая функции, можете сделать наоборот!
# Используйте символ * для распаковки кортежей и ** для распаковки словарей
args = (1, 2, 3, 4)
kwargs = {'a': 3, 'b': 4}
all_the_args(*args) # эквивалетно (1, 2, 3, 4)
all_the_args(**kwargs) # эквивалентно foo(a=3, b=4)
all_the_args(*args, **kwargs) # эквивалентно foo(1, 2, 3, 4, a=3, b=4)

# Область определения функций. ВАЖНО!!!
x = 5
def setX(num):
    # Локальная переменна x - это не то же самое, что глобальныя переменная x
    x = num
    print(x) # 43

def setGlobalX(num):
    global x
    print(x) # 5
    x = num # Глобальная переменная x теперь равна 6
    print(x) # 6

setX(43)
setGlobalX(6)

# В Python функции - "объекты первого класса"
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
add_10(3) # 13
s = create_adder(10)(3) # Аналогичная запись

# Также есть и анонимные функции
(lambda x: x > 2)(3) # True

# Есть встроенные функции высшего порядка
map(add_10, [1, 2, 3]) # [11, 12, 13]
filter(lambda x: x > 5, [3,4,5,6,7]) # [6, 7] В консоли не сработало.

# Для удобного отображения и фильтрации можно использовать списочные включения
[add_10(i) for i in [1, 2, 3]] # [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5] # [6, 7]


#-------------5 блок - Классы-------------

